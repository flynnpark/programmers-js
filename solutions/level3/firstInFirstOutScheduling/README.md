# [선입 선출 스케줄링](https://school.programmers.co.kr/learn/courses/30/lessons/12920)

## 문제 설명

처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다.

이 CPU는 다음과 같은 특징이 있습니다.

- CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다.
- 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다.
- 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다.
- 처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를 return 하는 solution 함수를 완성해주세요.

## 제한 사항

- 코어의 수는 10,000 이하 2이상 입니다.
- 코어당 작업을 처리하는 시간은 10,000이하 입니다.
- 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다.

## 입출력 예

| n   | cores   | result |
| --- | ------- | ------ |
| 6   | [1,2,3] | 2      |

## 입출력 예 설명

### 입출력 예 #1

처음 3개의 작업은 각각 1,2,3번에 들어가고, 1시간 뒤 1번 코어에 4번째 작업,다시 1시간 뒤 1,2번 코어에 5,6번째 작업이 들어가므로 2를 반환해주면 됩니다.

## 문제 풀이

처음에는 역시나 쉽게 `for`문을 사용하여 `n`만큼 세면서 구하려고 했다. `O(n)`이면 괜찮다고 생각했는데, 역시 문제에서 원하는 건 이게 아니었던 것 같다. 효율성 테스트를 모두 실패했다. 여기서 생각해낸 알고리즘은 이분탐색이었다.

먼저 문제에서 주어진 예시를 가지고 생각해보자.

| 시간 | core 1 | core 2 | core 3 | 진행된 작업의 수 |
| ---- | ------ | ------ | ------ | ---------------- |
| 0    | O      | O      | O      | 3                |
| 1    | O      |        |        | 4                |
| 2    | O      | O      |        | 6                |
| 3    | O      |        | O      | 8                |
| 4    | O      | O      |        | 10               |
| 5    | O      |        |        | 11               |

위 표를 보면 코어의 작업 처리 주기의 배수가 되는 시간에 새로운 작업이 추가된다는 사실을 알 수 있다. 이를 가지고, 어떤 시간(`hour`)이 주어졌을 때, `hour`의 약수에 해당하는 코어 번호만큼의 작업이 총 작업량에 추가된다.

- 어떤 시간 `hour`가 주어졌을 때, `cores`의 요소가 `hour`의 약수에 해당하는 경우 해당 요소는 새로운 작업이 할당된다.
- 어떤 시간 `hour`가 주어졌을 때, 총 작업량 = `hour - 1`의 총 작업량 + `hour`시간에 추가된 작업의 수

우리가 필요한 것은 총 작업량 `n`이 주어졌을 때, `n`개의 작업을 처리할 수 있는 최소시간을 구하는 것이다. 이 때의 시간대를 구한다면 이전의 시간대 `hour - 1`에서 처리된 작업량의 갯수를 구하여 마지막 작업이 몇 번째 코어에서 진행되어야 하는지 계산할 수 있다. 때문에 시간을 매개변수로 삼아 이분탐색을 진행한다.

이분탐색에서 구해주는 시간값인 `mid`값을 기준으로 처리하는 작업의 갯수를 구하고, 이 값과 `n - cores.length`값을 비교하여 이보다 크거나 작은 값을 만족하는 시간을 구한다. 이 때, `mid`는 최소-최대값 사이에 어떤 시간대가 설정되는데, 이 시간에 몇 개의 작업을 처리할 수 있는지 계산이 필요하다. 이는 각 `mid/cores[i]`의 볷의 누적합과도 같다. 그리고 이 값이 `n`과 같을 때를 구해야 한다.

이분탐색을 마친다면 `left/right`에는 `n - cores.length`의 작업량을 마칠 수 있는 시간대가 담기게 된다. 이 시간을 가지고 마지막 작업을 처리하는 코어의 위치를 구할 수 있다. 운이 좋다면 `left` 시간대에 마지막 작업을 처리하는 코어가 있을 수도 있지만, 이 값이 항상 `n - cores.length`와 일치한다는 보장이 없다. 때문에 `left - 1`의 시간대에서 처리된 작업량 수를 먼저 계산하고, 남은 작업의 수를 가지고 `left` 시간에 마지막 작업을 처리하는 코어의 번호를 알아내면 된다.
